---
title: "Topography processing"
output: html_notebook
---

This script does the topographical processes and produces outputs include area, drainage area, basin division, slopes, mask, marked, etc. 
Calculations are done on Cyverse with files temporarily transferred into Rstudio and saved out to Avra.

#1. Set up the working directories, get functions ready and read all the files
##specify all the directories, need to be changed accordingly
```{r identify all the directories}
rm(list=ls())
#here are all the directories will be sepecified in the code
#func_dir="/Users/junzhang/Documents/Topography/R_codes/Jun_test/functions/Github" #where you store all the functions to be used
#outdir="/Users/junzhang/Documents/Topography/R_codes/Jun_test/outputs/github_funcs" # store output files

#if you are reading data directly from local computer
#localdir="/Users/junzhang/Documents/Topography/CONUS2.0/iget_data" #where you store all the input files, dem, mask, etc.

#if you are reading from Avra
domain_idir="/iplant/home/shared/avra/CONUS2.0/Inputs/domain/" #file locations of domain data in avra
NWM_idir="/iplant/home/shared/avra/CONUS2.0/Inputs/NWM_Files/Upscaled_Files"#file locations of NWM data in avra
localdir="/Users/junzhang/Documents/Topography/CONUS2.0/iget_data"#the local directory you want to store the data from avra
domain_local=paste(localdir,'domain',sep="/") #the local directory for the domain data
NWM_local=paste(localdir,'NWM_files',sep="/") #the local directory for the NWM data

func_dir="C:/Users/Jun/A_Jun/mac_backup/Topography/R_codes/Jun_test/functions/Github"
input_local="C:/Users/Jun/A_Jun/mac_backup/Topography/CONUS2.0"
outdir="C:/Users/Jun/A_Jun/mac_backup/Topography/R_codes/Jun_test/outputs/github_funcs"

```

##thresholds and river network used in different scenarios
```{r define thersholds and input streamfile}
# Epsilon - value to be added if adjacent cells have the same elvation
ep=0.01
#  choose river network file
riverorder=5
if (riverorder==5){
  riverfile="1km_upscaledNWM_ChannelOrder5_mod2.tif"
} 
if (riverorder==3){
  riverfile="1km_upscaledNWM_ChannelOrder3_mod.tif"
  }
RiverfileLoc=paste(input_local,"/NWM_files/",riverfile,sep="")
#specify the run name
RunName=paste("Str",riverorder,"LakSink_Ep",ep,"_",sep="")#run name for PF files
#RunName="Str5LakSink_EP0.01_"
RunNameQGIS=paste("HSProc_Stream",riverorder,sep="")#runname for QGIS outs
#RunName="HSProc_Stream5"
```

##load all the packages and functions used for calculation
```{r setup}
#load all the packages in r
library('fields') #install the packages first before loading
library("raster")
library("sp")
library("rgdal")

#setup the function directory and sources all the functions
setwd(func_dir)
source("./functions/D4_Traverse.R")
#source("./functions/D4_Traverse_beta.R")
source("./functions/Init_Queue.R")
source("./functions/Stream_Traverse.R")
source("./functions/Find_Orphan.R")
source("./functions/drainage_area.R")
source("./functions/Slope_Calc.R")
source("./functions/Slope_Calc_Upwind.R")
```

#2. Read all the input files 
##including dem, mask, channel, border, lake borders, lake mask, sink masks
## makes the rasters to matrices and pre-process of the matrices 
```{r, read all the input files}
#download the data from avra
mask_idir=paste(domain_idir,'conus_1km_PFmask2.tif',sep="/")
borderR_idir=paste(domain_idir,'1km_PF_BorderCells2.tif',sep="/")
Lborder_idir=paste(domain_idir,'conus_1km_PFmask_selectLakesborder.tif',sep="/")
lakesR_idir=paste(domain_idir,'conus_1km_PFmask_selectLakesmask.tif',sep="/")
sinkR_idir=paste(domain_idir,'conus_1km_PFmask_manualsinks.tif',sep="/")
demR_idir=paste(NWM_idir,'1km_upscaledNWM_DEMmin2.tif',sep="/")
channelR_idir=paste(NWM_idir,'1km_upscaledNWM_ChannelOrder5_mod2.tif',sep="/")
system(paste('iget -KrfP', mask_idir, domain_local, sep=" "))
system(paste('iget -KrfP', borderR_idir, domain_local, sep=" "))
system(paste('iget -KrfP', Lborder_idir, domain_local, sep=" "))
system(paste('iget -KrfP', lakesR_idir, domain_local, sep=" "))
system(paste('iget -KrfP', sinkR_idir, domain_local, sep=" "))
system(paste('iget -KrfP', demR_idir, NWM_local, sep=" "))
system(paste('iget -KrfP', channelR_idir, NWM_local, sep=" "))

setwd(local_dir)
#Read in the stream order file and the Grid mask
maskR=raster("./Domain/conus_1km_PFmask2.tif")
#channelR=raster("./MyLayers/1km_upscaledNWM_ChannelOrder5_mod.tif")
#channelR=raster("../MyLayers/1km_upscaledNWM_ChannelOrder3_mod.tif")
channelR=raster(RiverfileLoc)
#channelR=raster("../MyLayers/1km_upscaledNWM_ChannelOrder3.tif")
borderR=raster("./Domain/1km_PF_BorderCells2.tif")
demR=raster("./NWM_files/1kmPF_upscaledNWM_DEMmin2.tif")
LborderR=raster("./Domain/conus_1km_PFmask_selectLakesborder.tif") #Border cells of lakes
lakesR=raster("./Domain/conus_1km_PFmask_selectLakesmask.tif") #Lake mask - 1 for lakes, 0 for everything else
sinksR=raster("./Domain/conus_1km_PFmask_manualsinks.tif") #sinks Mask - 1 for cells inside domain, 0 for cells outside domain, 2 for sinks

#make sure all the rasters are in the same dimension
#crop the channels from the NWM extent to the PF extent
channelRc=crop(channelR, extent(channelR,334,3589,97,4538))

#make the rasters into matrices
channel=as.matrix(channelRc)
mask=as.matrix(maskR)
border=as.matrix(borderR)
Lborder=as.matrix(LborderR)
lakes=as.matrix(lakesR)
dem=as.matrix(demR)
sinks=as.matrix(sinksR)

#mask out the channel cells outside the domain
channelm=channel*mask

#mask out the channel cells that fall inside lakes
lakeind=which(lakes==1)
channelm[lakeind]=0

#Transform so [i,j] indexing works directly as x and y location 
ny=nrow(channelm)
nx=ncol(channelm)
channelmT=t(channelm[ny:1,])
demT=t(dem[ny:1,])
borderT=t(border[ny:1,])
LborderT=t(Lborder[ny:1,])
lakesT=t(lakes[ny:1,])
maskT=t(mask[ny:1,])
sinksT=t(sinks[ny:1,])

#make a mask with the lakes removed by combining the lake coverage with the domain mask
lakeindT=which(lakesT==1)
LakemaskT=maskT
LakemaskT[lakeindT]=0

#Make a mask of sinks (i.e. cells with a value of 2 in the sink raster)
#Note the sinks are just single cells so for processing treat them just like a border cell
sinklist=which(sinksT==2)
nsink=length(sinklist)
SborderT=sinksT
SborderT[]=0
SborderT[sinklist]=1

#check that you aren't upside down and backwards somehow...
#if you've done it correctly this should work without
#any additional transforming on the matrix
#image.plot(channelmT, zlim=c(0.5,1))
#image.plot(borderT, zlim=c(0.5,1))
#image.plot(demT)

#D4 numbering
d4=c(1,2,3,4) # Numbers to assign to flow directions ordered, down, left, top, right
```

#3. Generate the streamflow raster based on the observed network from NWM

## Start off putting any boundary river cell in the queue
##NOTE: skipping assigning directions on these for now but will need to assign flow directions to every edge cell at some point
```{r put boundwary river cell in the queue}
AllBord=borderT+LborderT +SborderT#adding lake border + sinks+ to border
init=InitQueue(demT, initmask=channelmT, domainmask=maskT, border=AllBord) #outputs include the init$mask (channel mask), init$queue(x,y and elevation of cells in the queue), init$marked(cells marked as processed), init$basins(basin number)
print(paste("initial queue", nrow(init$queue)))
print(paste("Total Stream cells:", sum(channelmT)/10^6, "million"))
```

##Traverse the stream network
```{r}
t0=proc.time()
trav1 = StreamTraverse(dem=demT, mask=channelmT, queue=init$queue, marked=init$marked, basins=init$basins, printstep=F, epsilon=ep)
t1=proc.time()
print(paste("First Pass:", round(t0[3]-t1[3],1), "sec"))
print(paste("First Pass:", round(sum(trav1$marked)/sum(channelmT)*100,1), " % cells processed"))

#maskcol=colorRampPalette(c('white', 'red'))
#image.plot(trav1$mask, zlim=c(0.5,1),  col=maskcol(2), graphics.reset=F)
#image.plot(trav1$marked, zlim=c(0.5,1),  col=rev(grey.colors(2)), graphics.reset=F, add =T)
```

##Look for orphaned branches and continue traversing until they are all connected
```{r, search for orphan branches}
norphan=1
lap=1
while(norphan>0){
  t1=proc.time()
  #look for orphan branches
  #RivBorder=borderT+trav1$marked #mask of marked rivers+boundaries
  RivBorder=borderT+LborderT +SborderT+trav1$marked
  RivBorder[RivBorder>1]=1
  orphan=FindOrphan(trav1$dem, mask=channelmT, marked=RivBorder)
  norphan=orphan$norphan
  print(paste("lap", lap, norphan, "orphans found"))
  
  #go around again if orphans are found
  if(norphan>0){
    trav2 = StreamTraverse(trav1$dem, mask=channelmT, queue=orphan$queue, marked=trav1$marked, basins=trav1$basins, step=trav1$step, direction=trav1$direction, printstep=F, epsilon=ep)
    trav1=trav2
    lap=lap+1
    t2=proc.time()
    print(paste("Lap", lap , round(t2[3]-t1[3],1), "sec"))
  } else {
    print("Done!  No orphan branches found")
  }
  
} #end while
print(paste("Final pass:", round(sum(trav1$marked * channelmT)/sum(channelmT)*100,1), " % cells processed"))
t3=proc.time()
print(paste("Total Time:" , round(t3[3]-t0[3],1), "sec"))

```

##plot outputs 
```{r, plot outputs}
maskcol=colorRampPalette(c('white', 'darkgreen'))
image.plot(trav1$mask, zlim=c(0.5,1),  col=maskcol(2), graphics.reset=F)
#image.plot(trav1$marked, zlim=c(0.5,1),  col=rev(grey.colors(2)), graphics.reset=F, add =T)
stepplot=trav1$step
stepplot[trav1$step==0]=NA
image.plot(stepplot, zlim=c(0.5,max(stepplot, na.rm=T)),  col=rev(heat.colors(10)), add=T, graphics.reset=F)

maskcol=colorRampPalette(c('white', 'red'))
image.plot(trav1$mask, zlim=c(0.5,1),  col=maskcol(2), graphics.reset=F)
image.plot(trav1$marked, zlim=c(0.5,1),  col=rev(grey.colors(2)), graphics.reset=F, add =T)
```

##write out tif files
```{r, write out tifs for QGIS}

#just use one of the tifs that were read in and overwrite
#the values so you are sure the grid doesn't change

#rname="Order5_LakesSinks"
#steprast=maskR
#values(steprast)=t(trav1$step[, ny:1])
#steprast=setMinMax(steprast)
#writeRaster(steprast, paste("River_Proc_", rname, "_Step.tif", sep=""), format='GTiff', overwrite=T)
##plot(steprast)

#steprast=maskR
#values(steprast)=t(trav1$marked[, ny:1])
#writeRaster(steprast, paste("River_Proc_", rname, "_marked.tif", sep=""), format='GTiff', overwrite=T)
##plot(steprast)

#steprast=maskR
#values(steprast)=t(trav1$basins[, ny:1])
#writeRaster(steprast, paste("River_Proc_", rname, "_basin.tif", sep=""), format='GTiff', overwrite=T)
##plot(steprast)
```


#initialize the queue with every cell on the processed river and the boundary
##to do this use the marked rivers from the last step plus the edge cells as the boundary and the mask
```{r initialize the updated queue with the marked rivers}
RivBorder=borderT+trav1$marked+ LborderT + SborderT #domain border+lake border +traveresed rivers
#maskcol=colorRampPalette(c('white', 'red'))
#image(RivBorder, zlim=c(0.5, 1), col=maskcol(2))

#init=InitBorder(trav1$dem,  border=RivBorder)
init=InitQueue(trav1$dem, border=RivBorder)
#image(init$marked, zlim=c(0.5, 1), col=maskcol(2))
```

#4. Process all the cells outside the channel network
```{r, process cells outside the river}
#t4=proc.time()
#travHS=D4Traverse(trav1$dem, queue=init$queue, marked=init$marked, mask=maskT, direction=trav1$direction, basins=trav1$basins, step=trav1$step, epsilon=ep, printstep=T)
#t5=proc.time()
#print(paste("Total Time:" , round(t5[3]-t4[3],1), "sec"))

t4=proc.time()
#travHS=D4TraverseB(trav1$dem, queue=init$queue, marked=init$marked, mask=maskT, direction=trav1$direction, basins=trav1$basins, step=trav1$step, epsilon=ep, printstep=F, nchunk=1000)
travHS=D4TraverseB(trav1$dem, queue=init$queue, marked=init$marked, mask=LakemaskT, direction=trav1$direction, basins=trav1$basins, step=trav1$step, epsilon=ep, printstep=F, nchunk=1000) #adding in lakes
t5=proc.time()
print(paste("Total Time:" , round(t5[3]-t4[3],1), "sec"))
```
## calculate the drainage area
```{r, calculate the drainage area}
#these lines are for if you are reading in an old one to process
#dirR=raster("HSProc_Stream5_direction.tif")
#dirR=raster("HSProc_direction.tif")
#dirM=as.matrix(dirR)
#dirT=t(dirM[ny:1,])

dirT=travHS$direction
#dirT[maskT==0]=0
#dirT[borderT==1]=0 #just assigning something to border cells for now
#area=drainageArea(dirT, mask=maskT, border=borderT, printflag=T)
#dirT[LakemaskT==0]=0
#dirT[AllBord==1]=0 #just assigning something to border cells for now
#area=drainageArea(dirT, mask=LakemaskT, d4=c(1,2,3,4), printflag=T)
area=drainageArea(dirT, mask=LakemaskT, d4=c(1,2,3,4), printflag=T)

#image(travHS$marked)
#image(travHS$step)

#image(travHS$basins,zlim=c(0.5, max(travHS$basins)), col=grey.colors(10))
#maskcol=colorRampPalette(c('white', 'red'))
#image(trav1$marked,zlim=c(0.5,1), col=maskcol(2), add=T)
```
##calculate the slope
```{r calcuate the slope}
demprocT=travHS$dem

slopes=SlopeCalc(demprocT, LakemaskT, cutmax=T, maxTH=0.5)
#!!!! Need double check with the slope calculation function
#slopes=SlopeCalcUP(dem=demprocT, direction=dirT, dx=1000, dy=1000, mask=LakemaskT)
#image(slopes$slopex)
#image(slopes$slopey)
```
#5. write outputs
## write slopes in PF format
```{r write the outputs}
setwd(outdir)
slopex=slopey=rep(0, nx*ny)
jj=1
for(j in 1:ny){
  print(j)
  for(i in 1:nx){
    slopex[jj]=slopes$slopex[i,j]
    slopey[jj]=slopes$slopey[i,j]
    jj=jj+1
  }
}

#Check for flats
nflat=length(which(slopes$slopex==0 & slopes$slopey==0 & LakemaskT==1))
print(paste(nflat, "Flat cells found"))

range(slopes$slopex)
range(slopes$slopey)

length(which(slopes$slopex>0.5))
length(which(slopes$slopey>0.5))

fout=paste(RunName, "TH0.5_slopex.sa", sep="")
write.table( t(c(nx,ny,1)), fout, append=F, row.names=F, col.names=F)
write.table(slopex, fout, append=T, row.names=F, col.names=F)
fout=paste(RunName, "TH0.5_slopey.sa", sep="")
write.table( t(c(nx,ny,1)), fout, append=F, row.names=F, col.names=F)
write.table(slopey, fout, append=T, row.names=F, col.names=F)
```

##test just initializing from boundaries and processing whole domain
```{r initializing to do everything from the boders to match fortran}
#
#setwd("/Users/lauracondon/Dropbox/Research/Research/CONUS_2.0/DEM_Processing/MyTesting")
#source("./functions/D4_Traverse_beta.R")
#setwd("/Users/lauracondon/Documents/CONUS_2.0/Grid_Setup/DEM_Processing")


#init=InitBorder(dem=demT, border=borderT)

#ep=0.01
#t4=proc.time()
#travHS=D4TraverseB(demT, queue=init$queue, marked=init$marked, mask=maskT,  basins=init$basins, epsilon=ep, printstep=F, nchunk=100)
#t5=proc.time()
#print(paste("Total Time:" , round(t5[3]-t4[3],1), "sec"))
```

## write outs for QGIS
```{r outs for QGIS}
#RunNameQGIS="HSProc"
#RunNameQGIS="Str5LakSink_EP0.01"
#RunNameQGIS="HSProc_Stream5"
#step
temprast=maskR
values(temprast)=t(travHS$step[, ny:1])
temprast=setMinMax(temprast)
fout=paste(RunNameQGIS, "_step.tif", sep="")
writeRaster(temprast, fout, format='GTiff', overwrite=T)
plot(temprast)

#basins
temprast=maskR
values(temprast)=t(travHS$basins[, ny:1])
temprast=setMinMax(temprast)
fout=paste(RunNameQGIS, "_basins.tif", sep="")
writeRaster(temprast, fout, format='GTiff', overwrite=T)
#plot(temprast)

#direction
temprast=maskR
values(temprast)=t(travHS$direction[, ny:1])
temprast=setMinMax(temprast)
fout=paste(RunNameQGIS, "_direction.tif", sep="")
writeRaster(temprast, fout, format='GTiff', overwrite=T)
#plot(temprast)

#dem
temprast=maskR
values(temprast)=t(travHS$dem[, ny:1])
temprast=setMinMax(temprast)
fout=paste(RunNameQGIS, "_dem.tif", sep="")
writeRaster(temprast, fout, format='GTiff', overwrite=T)
#plot(temprast)

#marked
temprast=maskR
values(temprast)=t(travHS$marked[, ny:1])
temprast=setMinMax(temprast)
fout=paste(RunNameQGIS, "_marked.tif", sep="")
writeRaster(temprast, fout, format='GTiff', overwrite=T)
#plot(temprast)

#mask
temprast=maskR
values(temprast)=t(travHS$mask[, ny:1])
temprast=setMinMax(temprast)
fout=paste(RunNameQGIS, "_mask.tif", sep="")
writeRaster(temprast, fout, format='GTiff', overwrite=T)
#plot(temprast)

#area
temprast=maskR
values(temprast)=t(area[, ny:1])
temprast=setMinMax(temprast)
fout=paste(RunNameQGIS, "_drainageArea.tif", sep="")
writeRaster(temprast, fout, format='GTiff', overwrite=T)
#plot(temprast)

#slopex
temprast=maskR
values(temprast)=t(slopes$slopex[, ny:1])
temprast=setMinMax(temprast)
fout=paste(RunNameQGIS, "_slopex.tif", sep="")
writeRaster(temprast, fout, format='GTiff', overwrite=T)

#slopey
temprast=maskR
values(temprast)=t(slopes$slopey[, ny:1])
temprast=setMinMax(temprast)
fout=paste(RunNameQGIS, "_slopey.tif", sep="")
writeRaster(temprast, fout, format='GTiff', overwrite=T)
```
##Write out a bunch of outputs in SA for PFB and silo
```{r}
#Write the files out in PF format
dirPF=demPF=maskPF=areaPF=basinPF=channelPF=rep(0, nx*ny)
jj=1
for(j in 1:ny){
	print(j)
	for(i in 1:nx){
		dirPF[jj]=travHS$direction[i,j]
		demPF[jj]=travHS$dem[i,j]
		maskPF[jj]=travHS$mask[i,j]
		areaPF[jj]=area[i,j]
		basinPF[jj]=travHS$basins[i,j]
		channelPF[jj]=channelmT[i,j]
		jj=jj+1
	}
}

#direction
#fout=paste(RunName, "_direction.sa", sep="")
#write.table( t(c(nx,ny,1)), fout, append=F, row.names=F, col.names=F)
#write.table(dirPF, fout, append=T, row.names=F, col.names=F)
#dem
fout=paste(RunName, "_procdem.sa", sep="")
write.table( t(c(nx,ny,1)), fout, append=F, row.names=F, col.names=F)
write.table(demPF, fout, append=T, row.names=F, col.names=F)
#mask
fout=paste(RunName, "_mask.sa", sep="")
write.table( t(c(nx,ny,1)), fout, append=F, row.names=F, col.names=F)
write.table(maskPF, fout, append=T, row.names=F, col.names=F)
#area
fout=paste(RunName, "_area.sa", sep="")
write.table( t(c(nx,ny,1)), fout, append=F, row.names=F, col.names=F)
write.table(areaPF, fout, append=T, row.names=F, col.names=F)
#basin
fout=paste(RunName, "_basins.sa", sep="")
write.table( t(c(nx,ny,1)), fout, append=F, row.names=F, col.names=F)
write.table(basinPF, fout, append=T, row.names=F, col.names=F)
#river mask
fout=paste(RunName, "_RivMask.sa", sep="")
write.table( t(c(nx,ny,1)), fout, append=F, row.names=F, col.names=F)
write.table(channelPF, fout, append=T, row.names=F, col.names=F)
```


